( function( ns ){

	ns.DOM = {};

	var DOMNodes = ["a","abbr","acronym","address","area","article","aside","audio","b","base","bdo","bdi","big","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","command","dd","del","datalist","details","dfn","dir","div","dl","doctype","dt","em","embed","fieldset","figcaption","figure","font","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","img","input","ins","keygen","kbd","label","legend","li","link","map","mark","meta","meter","nav","noscript","noframes","object","ol","optgroup","option","output","p","param","pre","progress","q","rp","rt","ruby","samp","script","select","section","source","small","span","strong","strike","sub","sup","summary","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","tt","ul","u","video","wbr"],
		DOMNodeLength = DOMNodes.length,
		selfClosingTags = { br: true, img: true, input: true },
		RegExpMatchNode = / data-nodeid="[^"]*"/g,
		RegExpMatchVars = /\{\{([^\}]{1,})\}\}/g,
		RegExpSplitVars = /\{\{|\}\}/,
		
		RegExpTrimLeft = /^\s+/,
		RegExpTrimRight = /\s+$/,
		RegExpTrim = /^\s+(.*?)\s+$/,
		
		RegExpDoubleQuote = /\"/g,
		
		RegExpAttribute = /([^=\s]+)(\s*=\s*((\"([^"]*)\")|(\'([^']*)\')|[^>\s]+))?/gm,
		RegExpStartTag = /^<([^>\s\/]+)((\s+[^=>\s]+(\s*=\s*((\"[^"]*\")|(\'[^']*\')|[^>\s]+))?)*)\s*\/?\s*>/m,
		RegExpEndTag = /^<\/([^>\s]+)[^>]*>/m,
		
		RegExpMatchComma = /'/g,
		RegExpConvertJSCSSProp = /([A-Z])/g,
		RegExpConvertCSSProp = /(-.)/g,
		CSSJSCache = {},
		CSSCache = {},
		shorthand = false,
		templates = {},
		DOM = ns.DOM,
		nodeID = 0;
		
 	function parseItem( item ){
 	
		var type = typeof item,
			content = [],
			itemLength = 0;
			
		if ( type === "string" || type === "number" || type === "boolean" ) {
					
			return item;
			
		} else if( item === null || item === undefined ) {

			return "";

		} else if( type === "object" ) {
			
			if( item._h !== undefined ) {

				return item._h;

			} else if( item.unshift !== undefined ) {
			
				itemLength = item.length;
				
				for( i = 0; i < itemLength; i++ ) {			
					content.push( parseItem( item[i] ) );
				}
													
				return content.join("");
				
			} else {
			
				return "";
			}
			
		} else if( type === "function" ) {
				
			return parseItem( item() );
			
		} else {
		
			return "";
		}
	};

	function parseCDATA( args ) {

		var content = [], 
			i = 0,
			argument,
			argumentLength = args.length,
			attribute;
		
		for( i = 0; i < argumentLength; i++ ) {
			
			argument = args[ i ];
			
			if( argument === undefined || argument === null || argument === NaN ) { break; }

			content.push( parseItem( argument ) );
		}
							
		return { 
			_h: "<![CDATA[" + content.join() + "]]>", 
			markup: renderMarkupChain,
			compile: compileTemplateChain
		};
	};
	
	function parseComment( args ) {

		var content = [], 
			i = 0,
			argument,
			argumentLength = args.length,
			attribute;
		
		for( i = 0; i < argumentLength; i++ ) {
			
			argument = args[ i ];
			
			if( argument === undefined || argument === null || argument === NaN ) { break; }

			content.push( parseItem( argument ) );
		}
							
		return { 
			_h: "<!--" + content.join() + "-->", 
			markup: renderMarkupChain,
			compile: compileTemplateChain
		};
	};
		
	function parseNode( tagName, selfClosing, args ) {

		var content = [], 
			tag = [ "<" + tagName ], 
			i = 0,
			css = [], 
			argument,
			argumentLength = args.length,
			attribute;
				
		for( i = 0; i < argumentLength; i++ ) {
			
			argument = args[ i ];
			
			if( argument === undefined || argument === null || argument === NaN ) { break; }
			
			content.push( parseItem( argument ) );
						
			if( typeof argument === "object" && argument._h === undefined && argument.unshift === undefined ) {
								
				for( attr in argument ) {
									
					if( argument.hasOwnProperty( attr ) ) {
				
						attribute = argument[ attr ];

						if( typeof attribute === "string" || typeof attribute === "number" ) {
							
							tag.push( " " + attr + "=\"" + attribute + "\"" );
							
						} else if ( typeof attribute === "object" && attr === "style" ) {

							for( cssProp in attribute ) {
							
								if( attribute[cssProp] !== false && attribute[cssProp] !== undefined && attribute.hasOwnProperty( cssProp ) ) {
									
									css.push( ( CSSJSCache[ cssProp ] !== undefined ? CSSJSCache[ cssProp ] : CSSJSCache[ cssProp ] = cssProp.replace( RegExpConvertJSCSSProp, "-$1" ).toLowerCase() ) + ":" + attribute[cssProp] );
								}
							}
						}
					}
				}				
			}
		}
		
		if( css.length > 0 ) {		
			tag.push( " style=\"" + css.join(";") + ";\"" );
		}
								
		if( selfClosing === false ) {

			tag.push( ">" );
			tag.push( content.join("") );
			tag.push( "</" + tagName + ">" );
			
		} else {

			tag.push( "/>" );
			tag.push( content.join("") );
		}
							
		return { 
			_h: tag.join(""), 
			markup: renderMarkupChain,
			compile: compileTemplateChain
		};
	};
	
	function addNode( tag, selfClosing ) {

		if( DOM[ tag ] === undefined ) {
		
			DOMNodes.push( tag );
			
			if( selfClosing === true ) {
				selfClosingTags[ tag ] = true;
			}
		
			DOM[ tag ] = (function() {
				return function() {								
					return parseNode( tag, (selfClosing ? true : false), arguments )
				};
			})();
							
			if( shorthand === true && ( ns[ tag ] === undefined ) ) {	
				ns[ tag ] = DOM[ tag ];	
			}
		}
	}
		
	function enableShorthand(){

		var nodeName = "";
	
		shorthand = true;
		
		for( nodeName in DOM ) {
			if( DOM.hasOwnProperty( nodeName ) && ns[ nodeName ] === undefined ) {
				ns[ nodeName ] = DOM[ nodeName ];
			}		
		}
		
		Array.prototype.markup = function(){
			return renderMarkup.apply( this, this );
		};
	
		Array.prototype.compile = function(){
			return compile.apply( this, this );
		};
			
		String.prototype.markup = function(){
			return renderMarkup.call( this, this.toString() );
		};

		String.prototype.compile = function(){
			return compile.call( this, this.toString() );
		};

		String.prototype.parseHTML = function(){
			return parseHTML.call( this, this.toString() );
		};
	};

	function parseMarkup() {	

		var i = 0,
			n = 0, 
			content = [], 
			childLength = 0,
			funcOut,
			argumentLength = arguments.length,
			argument;
																							
		for( i = 0; i < argumentLength; i++ ) {
		
			argument = arguments[ i ];
			
			if( argument !== undefined && argument !== null ) {
			
				if( typeof argument === "string" || typeof argument === "number" || typeof argument === "boolean" ) {
				
					content.push( argument );
				
				} if( typeof argument === "object" ) {
				
					if( argument._h !== undefined ) {
					
						content.push( argument._h );
					
					} else if( argument.length !== undefined ) {
	
						childLength = argument.length;
					
						for( n = 0; n < childLength; n++ ) {
																
							content.push( parseMarkup.call( this, argument[ n ] ) );
						}
					}
					
				} else if( typeof argument === "function" ) {
				
					funcOut = argument();
					
					if( typeof funcOut === "string" ) {
	
						content.push( funcOut );
	
					} else {
	
						content.push( parseMarkup.call( this, funcOut ) );
					}
				}
			}
		}
		
		return content.join("");
	};

	function renderMarkup() {	
		return parseMarkup.apply( this, arguments ).replace( RegExpMatchNode, "" );
	};

	function renderMarkupChain() {	
		return parseMarkup.call( this, this ).replace( RegExpMatchNode, "" );
	};
	
	function compileTemplateChain(){
		return compileTemplate( this );
	};
	
	function compileTemplate() {
	
		var template = parseItem.apply( this, arguments ),
			vars = template.match( RegExpMatchVars ),
			parts = template.replace( RegExpMatchVars, "{{$$$1}}" ).split( RegExpSplitVars ),
			varsLength = 0,
			partsLength = 0,
			proc = [],
			procHash = {},
			func = [],
			args = ["data"],
			i = 0,
			parsedTemplate = {};
														
		if( vars !== null ) {
		
			varsLength = vars.length;
			partsLength = parts.length;
								
			for( i = 0; i < partsLength ; i++ ) {
			
				if( parts[i].charAt( 0 ) === "$" ) {
					func.push( "data." + parts[i].substr( 1, parts[i].length - 1 ) );				
				} else {
					func.push( "'" + parts[i].replace( RegExpMatchComma, "\\\'") +  "'" );
				}
			}

			proc.push( "return " + func.join("+") + ";" );
		
			return {
				_c: new Function( args, proc.join("") ),
				render: renderTemplateChain
			};
	
		} else {

			return {
				_c: new Function( args, "return\'" + template.replace( RegExpMatchComma, "\\\'") + "\';" ),
				render:renderTemplateChain
			};
		}
								
	};
	
	function renderTemplateChain( data ){
		return renderTemplate( this, data );
	};
	
	function renderTemplate( template, data ) {
		
		var i = 0,
			content = [],
			dataLength = 0;
			
		if( data !== undefined && data !== null ) {
		
			if( typeof data === "object" && data.splice !== undefined ) {
				
				dataLength = data.length;
				
				for( i = 0; i < dataLength; i++ ) {
				
					content.push( parseItem( template._c( data[i] ) ) );
				}
							
			} else if( typeof data === "object" ) {
				
				content.push( parseItem( template._c( data ) ) );
			}	

		} else {
		
			content.push( parseItem( template._c( {} ) ) );
		}
		
		return {
			_h: content.join(""),
			markup: renderMarkupChain
		};
	};
	
	
	// Add node methods
	for( i = 0; i < DOMNodeLength; i++ ) {
		addNode( DOMNodes[i], selfClosingTags[ DOMNodes[i] ] === true ? true : false );
	}

	DOM[ "comment" ] = (function() {
		return function() {								
			return parseComment( arguments );
		};
	})();

	DOM[ "cdata" ] = (function() {
		return function() {								
			return parseCDATA( arguments );
		};
	})();
	
	// DOM to template conversion
	var parseAttributes = function ( tagName, attributes ) {
		
		var attrs = [];
			
		attributes.replace( RegExpAttribute, function (a0, a1, a2, a3, a4, a5, a6 ) {
			attrs.push( parseAttribute( tagName, a0, a1, a2, a3, a4, a5, a6 ));
		});
		
		return attrs;
	};
	
	var parseAttribute = function (tagName, sAttribute, name ) {
		
		var value = arguments[7] ? arguments[8] : arguments[5] ? arguments[6] : arguments[3] ? arguments[4] : null;
		
		return { name: name, value: ( !value && !arguments[3] ) ? null : value };
	};
	
	var parseHTML = function( html ) {

		var index = 0,
			treatAsChars = false,
			level = 0,
			lastLevel = false,
			parsedCSS,
			tagPrefix = ( shorthand === true ? "" : "DOM."),
			out = [],
			attributesParsed,
			css = [],
			attr = [],
			fragment = "",
			rc;
			
		if( html.outerHTML ) {
			html = html.outerHTML;
		}

		while ( html.length > 0 ) {

			if ( html.substring(0, 4) === "<!--" ) {
			
				index = html.indexOf("-->");
				
				if (index != -1) {
				
					fragment = html.substring(4, index);
									
					if( level === lastLevel && lastLevel !== false || attr.length > 0 ) {
	
			    		out.push( "," + tagPrefix + "comment(\"" + fragment.replace( RegExpDoubleQuote, "\\\"") + "\")" );
			    		
					} else {
	
			    		out.push( tagPrefix+ "comment(\"" + fragment.replace( RegExpDoubleQuote, "\\\"") + "\")" );				
					}
					
					lastLevel = level;					
					
					html = html.substring(index + 3);
					treatAsChars = false;
					
				} else {
				
					treatAsChars = true;
				}
				
			} else if ( html.substring(0, 9) === "<![CDATA[" ) {
				
				index = html.indexOf( "]]>" );
				
				if (index != -1) {

					fragment = html.substring(9, index);

					if( level === lastLevel && lastLevel !== false || attr.length > 0 ) {
	
			    		out.push( "," + tagPrefix + "cdata(\"" + fragment.replace( RegExpDoubleQuote, "\\\"") + "\")" );
			    		
					} else {
	
			    		out.push( tagPrefix + "cdata(\"" + fragment.replace( RegExpDoubleQuote, "\\\"") + "\")" );				
					}
					
					lastLevel = level;
					
					html = html.substring(index + 3);
					treatAsChars = false;
					
				} else {
				
					treatAsChars = true;
				}
				
			} else if ( html.substring(0, 2) === "</" ) {
			
				if ( RegExpEndTag.test( html ) ) {
				
					rc = RegExp.rightContext;

					RegExp.lastMatch.replace( RegExpEndTag, function () {
																			
						if( selfClosingTags[ arguments[1] ] !== true ) {
							level--;
							lastLevel = level;
							out.push( ")" );
						}
				
						attr = [];
					});

					html = rc;
					treatAsChars = false;
					
				} else {
				
					treatAsChars = true;
				}
				
			} else if ( html.charAt(0) === "<" ) {
			
				if ( RegExpStartTag.test( html ) ) {
				
					rc = RegExp.rightContext;

					RegExp.lastMatch.replace( RegExpStartTag, function ( match, tagName, attributes ) {
											
						attributesParsed = parseAttributes( tagName, attributes );

						if( level === lastLevel || attr.length > 0 ) {
		
							out.push( "," + tagPrefix + tagName + "(" );
									
						} else if( level < lastLevel ) {

							out.push( tagPrefix + tagName + "(" );
							lastLevel = level;
							
						} else {
						
							out.push( tagPrefix + tagName + "(" );
							lastLevel = level;
						}
		
						for( i = 0; i < attributesParsed.length; i++ ) {
						
							if( attributesParsed[i].name === "style" ) {
		
								parsedCSS = parseCSSRules( attributesParsed[i].value );
														
								for( cssProp in parsedCSS ) {						
									css.push( "\"" + ( CSSCache[ cssProp ] !== undefined ? CSSCache[ cssProp ] : CSSCache[ cssProp ] = cssProp.replace( RegExpConvertCSSProp, function(x){ return x[1].toUpperCase(); } ) ) + "\":\"" + parsedCSS[ cssProp ] + "\"" )
								}
		
								attr.push( "\"style\":{" + css.join(",") + "}" );					
		
							} else {
							
								attr.push( "\"" + attributesParsed[i].name + "\":\"" + attributesParsed[i].value + "\"" );					
							}
						}
						
						if( attr.length > 0 ) {
							out.push( "{" + attr.join(",") + "}" );
						}
									
						if( selfClosingTags[ tagName ] === true ) {
							out.push( ")" );							
						} else {
							level++;
						}
						
					});

					html = rc;
					treatAsChars = false;
					
				} else {
				
					treatAsChars = true;
				}
			}
			
			if ( treatAsChars === true ) {
				
				index = html.indexOf( "<" );
				
				if (index === -1) {
										
					if( level === lastLevel && lastLevel !== false || attr.length > 0 ) {
	
			    		out.push( ",\"" + html.replace( RegExpDoubleQuote, "\\\"") + "\"");
			    		
					} else {
	
			    		out.push( "\"" + html.replace( RegExpDoubleQuote, "\\\"") + "\"");
					}
					
					html = "";
					
				} else {

					if( level === lastLevel && lastLevel !== false || attr.length > 0 ) {
	
			    		out.push( ",\"" + html.substring(0, index).replace( RegExpDoubleQuote, "\\\"") + "\"");
			    		
					} else {
	
			    		out.push( "\"" + html.substring(0, index).replace( RegExpDoubleQuote, "\\\"") + "\"");
					}
					
					html = html.substring(index);
					
				}
				
				lastLevel = level;
			}

			treatAsChars = true;
		}
						
		return out.join("");
	};

	var parseCSSRules = function(css) { 
	
	    var rule = {},
	    	declarations = css.split(";"),
	    	len = declarations.length,
	    	i = 0,
	    	loc = 0,
	    	property = "",
	    	value = "";
	    		    		    	    
	    for ( i = 0; i < len; i++) {
	    	        
	        if( declarations[i] !== "" ) {
	
	   	        loc = declarations[i].indexOf(":");    
		        property =  declarations[i].substring(0, loc).replace( RegExpTrim, "$1" );
		       	value = declarations[i].substring(loc + 1).replace( RegExpTrim, "$1" );
		
		        if ( property != "" && value != "" ) {
		        	rule[ property ] = value;
		        }
	        }
	    }
	    return rule;
	}
	
	// Expose public methods
	DOM.markup = renderMarkup;
	DOM.addNode = addNode;
	DOM.compile = compileTemplate;
	DOM.render = renderTemplate;
	DOM.enableShorthand = enableShorthand;

	DOM.parseHTML = parseHTML;

})( global );

// This pollutes the global namespace but makes calls a bit faster to write and call
// Comment out if you do not want this to happen and are okay with a small performance loss
// It is safe and will not overwrite existing window variables
DOM.enableShorthand();